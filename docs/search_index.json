[["index.html", "Intro to SQL for Querying Databases Overview", " Intro to SQL for Querying Databases Nicholas Alonzo Michele Tobias 2022-03-30 Overview This workshop teaches the basics of SQL using SQLite and SQLiteStudio. This workshop provides an overview of the utility and base SQL commands for working with data in a relational database. We’ll focus on querying data to get to know a database and answer questions, and joining data from separate tables. Goals After this workshop learners should be able to: Perform common SQL commands including viewing, filtering, aggregating, and joining data. Combine commands to construct a query to answer a specific question. Identify the benefits of working with SQL. Access additional resources for using SQL in other software like R. Prerequisites No prior programming experience is necessary: Have SQLiteStudio installed on your computer and running. View the install guide here. Download the workshop materials from the Google Drive link here. Make sure to unzip the folder and keep track of where it’s saved. There will be 2 files: lcdb.db intro_to_sql_spring22.sql "],["concepts.html", "1 Concepts 1.1 What is SQL? 1.2 What is a Relational Database? 1.3 What is a Relational Database Management System (RDBMS)? 1.4 Why do you want to learn to work with databases and SQL?", " 1 Concepts 1.1 What is SQL? SQL, also pronounced “sequel,” stands for “structured query language.” It’s a database programming language that allows you to answer questions about a database using a standard set of commands. 1.1.1 The SQL Query Blueprint Today we’ll learn about all the following SQL commands and how they’re used together to view, filter, aggregate, and join data. SELECT [DISTINCT] ... FROM ... [WHERE ...] [ [INNER | LEFT] JOIN ...] [GROUP BY ... [HAVING ...]] [ORDER BY ...] [LIMIT ...]; NOTE: Commands in brackets “[ ]” are optional Write commands in the order of the blueprint End queries with a semicolon “;” 1.2 What is a Relational Database? A relational database is a collection of tables (organized in rows and columns of data) that are related to each other in some way. If you’ve worked in Excel this would be the equivalent to sheets of data. Or, if you have experience with R or Python programming languages, this would be the equivalent to data frames. We’ll go more in-depth when we cover the workshop data set! 1.3 What is a Relational Database Management System (RDBMS)? A RDBMS is a software that interacts with databases, users, and other applications. For the workshop we’ll be working with SQLite. It’s a portable RDBMS that runs on Windows, MacOS, and Linux with no complex setup! Other popular RDBMS’s include MySQL, Postgres, and Microsoft SQL Server, but it’s an in-depth process to properly set up. Every RDBMS has it’s own implementation or “dialect” of the SQL standard. For SQLite there’s sqlite3, but everything we learn will be applicable to other popular RDBMS! 1.4 Why do you want to learn to work with databases and SQL? Work with large amounts of data Typically faster to run a process in a database than in a spreadsheet Store lots of data (compare with Excel’s row limits) Data management One database file stores many, many tables which is represented as one file in your file browser Write a query instead of making a new files or tabs Efficiency Write a few lines of code rather than lots of manual data manipulation SQL is meant for data manipulation Reproducibility Save queries as a record of your workflow Re-run code with updates 1.4.1 You’re Already Doing This! If you work with data, you’re probably already trying to answer specific questions: I would like to see XYZ that occurred in a certain time range. How many of X or Y are there? What unique values of X exist? "],["data-background-and-set-up.html", "2 Data Background and Set Up 2.1 SQLiteStudio 2.2 Entity Relationship Diagrams", " 2 Data Background and Set Up We’ll be working with the Library Checkouts Database, a fictitious dataset about users checking out books from the library. For more detailed information on how it was put together, please refer to the GitHub repository here. Although the data is fictious, the database supports enough scenarios for us to learn and practice SQL! 2.1 SQLiteStudio SQLiteStudio is a free, open source, multi-platform desktop application for browsing and editing SQLite database files. 2.1.1 The SQLiteStudio Interface SQLiteStudio Interface SQLiteStudio has a number of tools and panes to help you interact with your data. We can view databases (outlined in green) and also write and run queries (outlined in orange). 2.1.2 Load the SQL File Click the “Open SQL editor” icon and a new pane will appear. [1] Click the “Load SQL from file” icon and the file explorer window will pop up. [2] Navigate to the intro_to_sql_spring22.sql file on your computer and double-click. 2.1.3 Load the Database Click the “Add a database” icon and the Database dialog window will pop up. [3] Click the “Browse for existing database file on your local computer” icon and the file explorer window will pop up. Navigate to the lcdb.db file on your computer and double-click. The Database dialog window will appear again and click the OK button. 2.2 Entity Relationship Diagrams Before we get started with SQL, let’s cover what an Entity Relationship Diagram (ERD) is and why it’s important. An ERD is simply a visual representation of a database. They help you understand what data is available, how data is stored, and how data is related with one another. Understanding your database means you can determine what types of questions you can answer with SQL! Below is the Library Checkouts ERD: Lets break down the components of the ERD: Entities represent the tables in the database. Attributes represent the columns in the database. Data Types: Each attribute is made up of a certain data type. The most common data types you’ll interact with are numeric, string, date, or boolean. Primary Key (PK): This is a column(s) that uniquely identifies a row in a table. Foreign Key (FK): This is a column that references a primary key. It’s used to identify a relationship between tables. Relationships between tables are represented with lines connecting one entity to another The symbols at the end of the lines represent cardinality, the number of rows between two database tables. NOTE: Lucidchart does an excellent job of breaking down Entity Relationship Diagrams here. 2.2.1 Data Definitions Below are the data definitions of the tables and columns in the Library Checkouts DB. users: All users that have an account with the library column description data type id unique id of the user integer first_name first name of the user text last_name last name of the user text birth_date birth date of the user date phone cell phone of the user text email email address of the user text address address where the the user lives text city city where the user lives text state state where the user lives text zip_code zip code where the user lives integer checkouts: A log of when a user checks out a book from the library column description data type id unique id of the book checkout integer user_id id of the user who checked out a book integer book_id id of the book that was checked out integer checkout_date date the book was checked out by the user date days_checking_out number of days the user will checkout the book integer due_date date the book is due based off days_checking_out date return_date date the book was returned by the user date days_checked_out number of days the book was checked out for integer returned_with_damage a number to distinguish whether the book was returned with damage0 = the book was not returned with damage1 = the book was returned with damage integer books: All the books in the library inventory system column description data type id unique id of the book integer title title of the book text author name of the author text isbn isbn of the book text date_published date the book was published date publisher publisher of the book text format the format of the book Ex) Hardcover text pages the number of pages the book has integer book_genre_link: A table to link books with their respective genre(s) column description data type book_id id of the book integer genre_id id of the genre integer genres: All the genres in the library system column description data type id unique id of the genre integer name name of the genre text "],["hands-on.html", "3 Hands-On 3.1 Viewing Data 3.2 Filtering Data 3.3 Aggretating Data 3.4 Joining Data 3.5 Subqueries 3.6 Saving Query Results 3.7 Data Management", " 3 Hands-On 3.1 Viewing Data 3.1.1 SELECT &amp; FROM We’re ready to write our first query! Type this into the SQL editor pane: SELECT * FROM users; Place your cursor anywhere on SELECT and then click the Execute query button. This is the most common query you’ll write as you start exploring your data. SELECT is used to display the columns of tables you want and FROM is used to specifiy which table to get the columns from. The query asks the database to select everything (* means “everything”) from the table users. It ends with a semicolon to tell the database that this is the end of the request. The below query does exactly the same thing as the first one, hence the need for the end of query indicator. We can use new lines to help us organize queries to make them easier to read. SELECT * FROM users; NOTE: Capitalization in queries follows some best practices: SQL commands are in all caps Table names and column names are all lowercase 3.1.2 Selecting Columns What if we don’t want to see all of the columns in the table? We can ask for just the columns we want to see. Let’s get the first name, birth date, phone, city, and zip code. SELECT first_name, birth_date, phone, city, zip_code FROM users; NOTE: You can rearrange the columns however you’d like in the SELECT statement and select a column multiple times. 3.1.3 Column Referencing Another important nuance to writing queries is column referencing. This helps you distinguish from what table the columns come from. Use the table name followed by a period to reference the column. SELECT users.first_name, users.birth_date, users.phone, users.city, users.zip_code FROM users; NOTE: This is optional when working with one table. When you start working with multiple tables, it’ll be easier to keep track of where the columns come from. It’s especially important and often necessary to do this if your tables have the same column name. In general it’s best practice to reference your columns! 3.1.4 Aliasing Columns &amp; Tables Sometimes the default column or table name is not easy to read, interpret, or representitive of what the data actually is. We can use AS to rename (alias) a column or table temporarily in the query. Let’s rename a few columns from our previous query. This is handy if you’re planning to export this table for future use, especially if you’re sending it to someone else. SELECT first_name, birth_date AS dob, phone AS cell_phone, city, zip_code AS zip FROM users; Now let’s rename our table to students. SELECT first_name, birth_date AS dob, phone AS cell_phone, city, zip_code AS zip FROM users AS students; NOTE: Notice that you can alias a table and columns in the same query. This will come handy when we learn about JOIN! CHALLENEGE: How would you reference the columns when the table is aliased? Can you use users, students, or both? 3.1.5 Unique Values In your data exploration, you might want to know which unique values exist in a column. SELECT DISTINCT is the statement we run on one or more columns to achieve this. Let’s look at the users table again and see which cities our users live in. SELECT DISTINCT city FROM users; If we wanted to see unique combinations across multiple columns, we just add the columns we’re interested in. The query below shows unique city and zip code combinations. SELECT DISTINCT city, zip_code FROM users; 3.1.6 Ordering Results While we continue our data exploration, we also might want to sort the results in a specific way. You can sort on one or more columns with a combination of ascending or descending order using the ORDER BY command. Let’s sort the users table by birth date. SELECT * FROM users ORDER BY birth_date; By default, ORDER BY sorts in ascending order. We can sort in descending order to get users born more recently by adding DESC after the column. SELECT * FROM users ORDER BY birth_date DESC; CHALLENGE: How would you sort users by zip code in descending order and then birth date in ascending order? 3.1.7 Limiting Number of Rows Sometimes you’ll be working with a large table to analyze with lots of columns and rows. You can use LIMIT to reduce the number of rows the query returns to give you a snapshot of the data you’re working with. SELECT * FROM users LIMIT 10; 3.1.8 Commenting As we’re writing queries, sometimes we want to write helpful comments to ourselves and others. There’s two ways to write comments so that text won’t be interpreted as SQL. Single line comments: text following two dashses “–”, like so -- comment here Multiline comments: text between the characters “/* */”, like so /* comment here */ /* all users in the library system sorted by most recent birth date */ SELECT * FROM users ORDER BY birth_date DESC; -- sort most recent here CHECKPOINT: Try and use all viewing commands together to give you insight to the dataset. Write your insights in comments. 3.2 Filtering Data Now that we’ve seen some ways to view our data, let’s learn how we can filter our data! This is really the core of SQL, where we can start to answer our own questions about the data! We use the WHERE command to filter rows of a query by specifying one or more conditions. Below are common operators that can be used and combined in the WHERE clause to create conditions, some of which you may already be familiar with. Comparison Operators Arithmetic Operators = (equals) + (addition) &gt; (greater than) - (subtraction) &gt;= (greater than or equal to) * (multiplication) &lt; (less than) / (division) &lt;= (less than or equal to) % (modulus) &lt;&gt; or != (not equal to) Let’s write a query to find all users that live in Davis. SELECT * FROM users WHERE city = &#39;Davis&#39;; 3.2.1 AND &amp; OR Operators We can ask WHERE to meet multiple conditions using AND (when a record must match both conditions) OR (when a record can match either of two conditions) Let’s find all users who live in Davis and have a zip code of 95616. SELECT * FROM users WHERE city = &#39;Davis&#39; AND zip_code = 95616; Let’s now find all users who live in Davis or Sacramento. SELECT * FROM users WHERE city = &#39;Davis&#39; OR city = &#39;Sacramento&#39;; NOTE: AND &amp; OR will follow the order of operations. To use AND &amp; OR in the same query, wrap parenthesis around the OR conditions. 3.2.2 IN Operator Sometimes we find ourselves writing multiple OR conditions on the same column which can make our query look more complex than it really is. In this scenario we can condense multiple OR conditions using IN. Let’s rewrite our previous query to use IN. SELECT * FROM users WHERE city IN (&#39;Davis&#39;, &#39;Sacramento&#39;); 3.2.3 BETWEEN Operator We can also also filter using ranges of values with BETWEEN. This is handy when you’re working with numerical or date values and you don’t want to list out all possible values to meet your conditions. Let’s write a query to find all users born in the 1990’s. SELECT * FROM users WHERE birth_date BETWEEN &#39;1990-01-01&#39; AND &#39;1999-12-31&#39;; CHALLENGE: Find all users with a zip code from 95000 - 96000. 3.2.4 LIKE Operator LIKE is used to search for patterns in strings using the wildcard (%). % is placeholder that means it can match anything. LIKE is case-insensitive. Let’s look at an example to indicate we want to match the beginning of a string, but the end is allowed to vary. To show this, let’s find users that have a phone number area code that begins with 530 and can end with anything. SELECT * FROM users WHERE phone LIKE &#39;530%&#39;; NOTE: The wildcard % can be used multiple times depending on how complicated your pattern is. You can also use regular expressions in SQLite to match in more complicated situations. Read more about using regular expressions here. CHALLENGE: How would you write a query so that the wild card finds users with an email that ends with icloud.com? 3.2.5 IS NULL Operator So far we’ve worked with complete data, but how do we work with missing data? In databases, NULL means missing data. IS NULL is used to test whether there is missing data in a column. Let’s look at an example to find users with a missing address. SELECT * FROM users WHERE address IS NULL; CHALLENGE: How would you write a query to find users with a missing phone number or missing email? 3.2.6 NOT Operator There’ll be times where we want to find the opposite (negate) the conditions we create. To do this we use NOT combined with the other operators like so, NOT IN NOT BETWEEN NOT LIKE IS NOT NULL Below is a query to find users that do not have a phone number area code that begins with 530. SELECT * FROM users WHERE phone NOT LIKE &#39;530%&#39;; 3.3 Aggretating Data We’ve just looked at a number of ways to filter data, but now let’s look at some ways to aggregate data. 3.3.1 Count We can count the total number of rows in a table using the COUNT() function. Let’s see how many total books have been checked out. SELECT COUNT(*) AS total_checkouts FROM checkouts; NOTE: Notice how we’ve aliased the aggregated column to something interpretable and representative of what it is. You can combine DISTINCT with COUNT() using COUNT(DISTINCT column_name) to get a unique count of values in a column when duplicate values exist. CHALLENGE: Find the total number of users that have checked out a book. We can also include WHERE. Let’s see how many books were checked out just today. SELECT COUNT(*) AS total_checkouts FROM checkouts WHERE checkout_date = &#39;2022-04-11&#39;; 3.3.2 Average AVG() is another way to aggregate our data. Let’s find the average days a person is checking out a book for. SELECT AVG(days_checking_out) AS avg_days_checking_out FROM checkouts; 3.3.3 Sum We can also sum our data with SUM(). Let’s find the total number of books that were returned with damage. SELECT SUM(returned_with_damage) AS books_returned_with_damage FROM checkouts; Below is another way to accomplish the same task using COUNT() and WHERE. SELECT COUNT(*) AS books_returned_with_damage FROM checkouts WHERE returned_with_damage = 1; 3.3.4 Grouping Data So now you’ve seen several functions working on a single column, but we sometimes want to summarize our data in more sophisticated ways. Let’s see what grouping can do for our data. Let’s write a query that counts the number of books checked out per day. SELECT checkout_date, COUNT(book_id) AS books_checked_out FROM checkouts GROUP BY checkout_date; Notice here how we asked for two columns - the checkout_date and the count of book_id. CHALLENGE: You can also GROUP BY more than one column. How would you find the total number of times a person checked out a book on a given day? 3.3.5 Having HAVING is similar to WHERE, but it specifically works with GROUP BY. Perhaps we’re only interested in days that had more than 5 checkouts. Let’s see what that looks like: SELECT checkout_date, COUNT(book_id) AS books_checked_out FROM checkouts GROUP BY checkout_date HAVING COUNT(book_id) &gt; 5; Now we’ve seen how we can use functions to aggregate data and how grouping data can give us meaningful insights. There are, of course, other functions available in SQL and we can’t go over all of them here, but now you’ve seen how they work and can apply your knowledge to new functions you find. 3.4 Joining Data Joining tables allows us to combine information from more than one table into a new table. The tables need to have a key to do so. In our Library Checkouts ERD, the id column in books is a key column that links to book_id in checkouts and book_id in book_genre_link SQL has 4 main kinds of joins: NOTE: The above images come from the W3Schools’ SQL join page, an excellent resource for learning more about SQL. What kinds of joins are there? INNER JOIN: Returns records that have matching values in both tables; it gets you what’s in the middle of the venn diagram. LEFT JOIN: Returns all records from the left table, and the matched records from the right table; the “left” table is the first table you write in the query. RIGHT JOIN: Returns all records from the right table, and the matched records from the left table; the “right” table is the second table you write in the query or the “join” table. NOTE: This is not supported in SQLite, however switching the tables in a LEFT JOIN will emulate a RIGHT JOIN. FULL OUTER JOIN: Returns all records when there is a match in either left or right table; nulls are generated in the table when a row in one table doesn’t have a match in the other table. NOTE: This is not supported in SQLite, however you can emulate a FULL OUTER JOIN described here. Below are the steps for writing a JOIN: We start in just the same way: SELECT the columns we want in the output (using column references). Then we have the FROM statement to tell it which table to start with (this is our “left” table). Then we need our JOIN statement to say which table should get joined (this is our “right” table) Finally, we have to say which columns the join should be based on with ON . Let’s try an INNER JOIN to see how this works: SELECT checkouts.user_id, books.title AS book, checkouts.checkout_date FROM books INNER JOIN checkouts ON books.id = checkouts.book_id; We interpret the INNER JOIN query as, “all books that have been checked out.” Now let’s try a LEFT JOIN: SELECT checkouts.user_id, books.title AS book, checkouts.checkout_date FROM books LEFT JOIN checkouts ON books.id = checkouts.book_id; We interpret the LEFT JOIN query as, “all books and if they have been checked out or not.” You might be thinking, what would happed if the tables in the LEFT JOIN were flipped? We would get the same result as the INNER JOIN query! That’s because there’s no instances where a checkout without a book could ever happen! CHALLENGE: Can you write a query that contains the title of the books and the names of the genres they’re categorized to? 3.5 Subqueries So far we’ve been working with one SELECT statement, but we can actually combine multiple SELECT statements using subqueries. Subqueries are nested queries enclosed in parentheses that can be used with other commands like JOIN and WHERE. Below are 2 examples of these use cases. Let’s first look at a subquery in the WHERE clause: -- main query SELECT * FROM checkouts WHERE book_id IN ( -- subquery SELECT id FROM books WHERE format = &#39;Hardcover&#39; ); We retrieve hardcover books in a subquery. We then use the results of the subquery to filter the checkouts table using checkouts.book_id. In the end we get, “all checked out hardcover books.” NOTE: When writing a subquery with WHERE and IN, the subquery must select only one column for IN to filter on. Now let’s look at a subquery with JOIN: -- main query SELECT checkouts.user_id, hardcover_books.title AS book, checkouts.checkout_date, checkouts.return_date FROM checkouts INNER JOIN ( -- subquery SELECT * FROM books WHERE format = &#39;Hardcover&#39; ) AS hardcover_books ON checkouts.book_id = hardcover_books.id; We retrieve hardcover books in a subquery, just like before. Next, we write the subquery after JOIN and alias it hardcover_books. Finally, we join on the keys and return the columns we want in the main SELECT statement. NOTE: If you’re still a bit confused, just remember that every query results in a table. Subqueries give you the ability to create a “new” table on the fly even if that table didn’t exist in the database before. Also, note that both subquery examples are just different ways to get to the same result, “checked out hardcover books.” 3.6 Saving Query Results There will be times when we want to save the results of a query so we can reuse it later when needed. Two commands to save a query as a new database object follow: CREATE TEMPORARY TABLE This is a new table added to the database, just like the tables you’ve been working with, except it is only available in the current session. You typically do this to break down a complex problem into intermediate steps and pass your saved results to the final query. CREATE VIEW A view is simply a saved query that can be executed when called. The query you save will usually be made up of multiple tables with added conditions if needed. You can use it in pretty much the same way you would a table. The only major difference is that a view, because it is updating from other tables, is not able to be edited. If we want to create a temporary table, we just need to add CREATE TEMPORARY TABLE our_new_table_name AS at the beginning of the query (adding in our own table name, of course). This is what it looks like: CREATE TEMPORARY TABLE davis_resident_checkouts AS SELECT users.id AS user_id, users.first_name, users.last_name, books.title AS book, checkouts.checkout_date, checkouts.return_date FROM users INNER JOIN checkouts ON users.id = checkouts.user_id INNER JOIN books ON checkouts.book_id = books.id WHERE users.city = &#39;Davis&#39;; In much the same way we made the new table, we can make a view: CREATE VIEW davis_resident_checkouts AS SELECT users.id AS user_id, users.first_name, users.last_name, books.title AS book, checkouts.checkout_date, checkouts.return_date FROM users INNER JOIN checkouts ON users.id = checkouts.user_id INNER JOIN books ON checkouts.book_id = books.id WHERE users.city = &#39;Davis&#39;; 3.7 Data Management 3.7.1 Update Tables You might have noticed at the beginning the users table has NULL values across different columns. We can fix this fairly easily, but we need to be careful. It’s challenging to undo something in a database so we want to be sure we’re doing it right. Let’s update the NULL values in the users.address to “N/A”. It’s first helpful to write a query to be sure these are the records you want to update: SELECT * FROM users WHERE address IS NULL; Once you’ve confirmed, the below statement updates the NULL values to “N/A” UPDATE users SET address = &#39;N/A&#39; WHERE address IS NULL; The SET command specifically targets just the address column and replaces NULL values with “N/A” when the condition is met in the WHERE clause. It leaves the other values alone. If the WHERE clause is removed, it will set all values in the whole column to “N/A” overwriting the users address, so proceed with caution! 3.7.2 Add &amp; Populate a Column Sometimes we want to make a new column and add data into it. Let’s make a new column called country in the users table and populate it with “USA” if there is a value in the column state. First we’ll add the column and set the default value to “N/A”: ALTER TABLE users ADD country TEXT DEFAULT &#39;N/A&#39;; NOTE: The DEFAULT argument is optional, but if you leave it blank, it will make the default value NULL. Now we update all values in the column to be “USA” where the state is not null. UPDATE users SET country = &#39;USA&#39; WHERE state IS NOT NULL; "],["conclusion.html", "Conclusion", " Conclusion We covered a wide variety of SQL processes you might need in setting up a database and querying data. Did we cover everything you might need to know? Of course not. It’s only a 3 hour workshop and SQL is a big language. I highly encourage you to look at the resources below to learn more and expand your SQL skills. I also welcome pull requests and submitting issues for typo fixes or ideas for additional content. Resources W3Schools SQL Materials - This is an excellent reference for SQL syntax with a fun “try it yourself” feature. Sofware Carpentry’s SQL Novice Workshop Clark Fitzgeralds &amp; Nick Ulle’s SQL Workshop Clark Fitzgeralds &amp; Nick Ulle’s SQL Cheatsheet Michele Tobias’ Spatial SQL Workshop Lucidchart’s Entity Relationship Diagrams Overview Diversify Data Science’s Library Checkout Database - v0.1.0-alpha Working with SQL databases and queries in R: University of Michigan’s Stat 701 Class Notes RStudio’s Database Queries with R "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
